MINIFMT  TITLE '                                  MINIFMT - A Message G>
               enerator'
***********************************************************************
*                                                                     *
* Title -- MINIFMT                                                    *
*                                                                     *
* Function / Operation -- MINIFMT is a message generator program.  It *
*   is a proper superset of MICROFMT; all valid MICROFMT formats will *
*   produce the same results as MICROFMT.  Additional formatting      *
*   includes date and time formats, formats to translate the record   *
*   formats included with the DCB and Format 1 DSCBs, the DSORG in    *
*   the DCB and Format 1 DSCBs, and tabs and multiple space inserts.  *
*                                                                     *
* Status / Change Level --                                            *
*   V1L5 -- September 2016                                            *
*    - CNVTBIN rewritten to improve performance and reduce storage    *
*      foot print                                                     *
*      - Fewer registers saved / restored                             *
*      - One divide / multiply pair eliminated                        *
*      - Last multiply of hours by 1,000,000 changed to               *
*        two MHI reg,1000 to eliminate a SR and the storage for       *
*        F'1000000'.                                                  *
*      - Method to strip the packed decimal sign from the result      *
*        simplified.                                                  *
*    - Copyright added to SAVE macro                                  *
*   V1L4 -- January 2015                                              *
*    - Added LJUSTX external function to left justify the contents    *
*      of a text data srea.                                           *
*   V1L3 -- November 2014                                             *
*    - Add formst 10, a binary to decimal conversion that inserts ,   *
*      characters between every 3 digits, e.g., 1,035 rather than     *
*      1035, to make large numbers easier to read.                    *
*   V1L2 -- June 2010                                                 *
*    - Hex conversion for fields containing more than 7 bytes not     *
*      being done correctly                                           *
*   V1L1 -- June 2010                                                 *
*    - Blank not being inserted between the date and time for format  *
*      codes 4 and 5 if both a date code and time code are specified  *
*    - Tab problem                                                    *
*   V1L0 -- April 2010                                                *
*                                                                     *
* Calling sequence --                                                 *
*            LA    0,FMTWORK                                          *
*            LA    1,FORMAT                                           *
*            L     15,=V(MINIFMT)      MINIFMT CAN ALSO BE CALLED     *
*            BALR  14,15               USING BRAS OR BRASL            *
*            ...                                                      *
*   FMTWORK  DC    XL200'0'                                           *
*   FORMAT   DC    -- Format Specifications --                        *
*                                                                     *
*   Returns -- Address of generated output line in register 1.        *
*     All other registers are returned unchanged                      *
*                                                                     *
* Format Specification --                                             *
*   A format consists of two or more field specifications.  There are *
*   three types of field specifications --                            *
*   - End of format -- X'FF' or X'00'                                 *
*   - In line text -- AL1(length),C'in line text'                     *
*     Length can be 1 to 127                                          *
*   - Data conversion -- These data conversions are provided.         *
*     . Character, for data areas from 1 to 255 bytes.                *
*     . Binary to decimal, of unsigned 1, 2 and 3 byte fields, and    *
*       signed 4 byte fields                                          *
*     . Binary to hexadecimal, of data areas from 1 to 255 bytes. Two *
*       output bytes for each input byte                              *
*     . Insert blanks.                                                *
*     . Format system date and time                                   *
*     . Format date and time using a TIME DEC formatted date and      *
*       time.                                                         *
*     . Provide a tabbing capability                                  *
*     Each data conversion is specified as a multiple byte format --  *
*     Offset  Bit  Value Purpose                                      *
*        0     0     1 -- Indicates data conversion                   *
*        0     1     0 -- Address specified as an in-line 4 byte      *
*                         address constant                            *
*        0     1     1 -- Address specified as a 2 byte S type        *
*                         address                                     *
*                         The S-con base register can be registers 2  *
*                         through 13.  Since registers 14, 15, 0 and  *
*                         are used as link registers, their use in    *
*                         an S-con is limited.                        *
*        0    2-7    0 -- Copy text string to output line             *
*                    1 -- Translate 1 to 4 byte binary to decimal     *
*                    2 -- Translate 1 to 255 byte binary to           *
*                         hexadecimal digits                          *
*                    3 -- Provide input length for an undefined       *
*                         text or  hexadecimal conversion             *
*                    4 -- Format the system date and time.  The       *
*                         input length byte specifies the date        *
*                         format, the output length byte specifies    *
*                         the time format.  MINIFMT obtains the       *
*                         system date the first time this format is   *
*                         encountered.                                *
*                    5 -- Format the date and time in a TIME DEC      *
*                         storage area                                *
*                    6 -- Insert blanks                               *
*                    7 -- Tab.  A tab to a position higher than the   *
*                         current end of line inserts blanks.  The    *
*                         position is relative to the first byte in   *
*                         the line.                                   *
*                    8 -- Translate DCBRECFM/DS1RECFM                 *
*                    9 -- Translate DCBDSORG/DS1DSORG                 *
*                   10 -- Tranalate 1 to 4 byte binary to decimal     *
*                         using an alternate format, nnn,nnn rather   *
*                         than nnnnnn                                 *
*        1    0-7    Input length.                                    *
*                    For codes 4 and 5, this byte contains a date     *
*                    format code --                                   *
*                     1 -- yyyy/mm/dd                                 *
*                     2 -- yy/mm/dd                                   *
*                     3 -- mm/dd/yyyy                                 *
*                     4 -- mm/dd/yy                                   *
*                     5 -- yyyy month dd                              *
*                     6 -- yy month dd                                *
*                     7 -- month dd, yyyy                             *
*                     8 -- yyyy                                       *
*                     9 -- yy                                         *
*                    10 -- mm    (Month as a two digit number)        *
*                    11 -- mmm   (Abbreviated month name)             *
*                    12 -- month (Full month name)                    *
*                    13 -- dd    (Day of month)                       *
*                    14 -- ddd   (Day of year)                        *
*                                                                     *
*                    Date codes that insert a 2 digit year makes      *
*                    your program Y2K conpatible if it is Y2K         *
*                    compliant in all other aspects                   *
*                                                                     *
*        2    0-7    Output length.  Not used for hex conversion.  If *
*                    0 is specified, for binary to decimal conversion *
*                    the output length is the length of the converted *
*                    number, for character conversion the output      *
*                    length is the input length with trailing blanks  *
*                    removed                                          *
*                                                                     *
*                    For codes 4 and 5, this byte contains a time     *
*                    format code --                                   *
*                     1 -- hh:mm       (24 hour clock)                *
*                     2 -- hh:mm xM    (xM is AM or PM)               *
*                     3 -- hh:mm:ss    (24 hour clock)                *
*                     4 -- hh:mm:ss xM (xM is AM or PM)               *
*                                                                     *
*                    If a date code and a time code are both          *
*                    present, a blank appears between the date and    *
*                    time.                                            *
*                                                                     *
*        3           Data address, as either a 2-bye S type address   *
*                    or a 4 byte address constant.                    *
*                                                                     *
* Attributes -- MINIFMT is reenterable, refreshable and reusable.  It *
*   operates in any key, problem or supervisor state.  It is  not     *
*   intended to operate in AR mode or the 64-bit addressing mode.  It *
*   will operate in the 24-bit addressing mode if the format, work    *
*   area, and any data referenced in the format is in the 24-bit      *
*   residence area.                                                   *
*                                                                     *
***********************************************************************
         SPACE 5
MINIFMT  RSECT
MINIFMT  AMODE ANY
MINIFMT  RMODE ANY
         PUSH  PRINT
         PRINT NOGEN
         DCBD  DSORG=QS,DEVD=DA    DEFINE DCB SYMBOLS
         POP   PRINT
MFMTWORK DSECT
MFMTWWRK DS    D                   DOUBLE WORD ALIGNED 8 BYTE WORK AREA
MFMTWDT  DS    2F                  SYSTEM DATE AND TIME
MFMTWEWK DS    0C' 999999999999999'
MFMTWLNG DS    C' 999,999,999,999,999'
MFMTWLEN DS    AL1                 LENGTH FROM FORMAT 3
MFMTWFLG DS    AL1                 NON-ZERO IF SYSTEM DATE AND TIME   ->
                                    STORED IN MFMFWDT
MFMTSAVE DS    AL1,0F
MFMTWLNE DS    2AL2                GENERATED OUTPUT LINE
MINIFMT  RSECT
         BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,12                ESTABLISH PROGRAM BASE REGISTER
         USING MFMTWORK,11         ESTABLISH WORK AREA ADDRESSABILITY
*        SAVE  (14,12),,MINIFMT-V1L4-&SYSDATE-&SYSTIME  SAVE REGISTERS
         SAVE  (14,12),,'MINIFMT V1L5 &SYSDATE &SYSTIME  Copyright (c) >
               2010, 2014-2016 J. Stephen Myers'
         LR    12,15               COPY ENTRY POINT ADDRESS TO REG 12
         LR    11,0                COPY WORK AREA ADDRESS TO REG 11
         MVI   MFMTWFLG,0          INDICATE SYSTEM DATE AND TIME NOT  ->
                                    IN WORKAREA
         LR    3,1                 COPY ADDRESS OF FORMAT TO REG 3
         LA    14,MFMTWLNE+4       LOAD START OF TEXT OUTPUT
MFMT0100 CLI   0(3),X'FF'          TEST IF END OF FORMAT
         JE    MFMT7600
         CLI   0(3),0
         JE    MFMT7600
         TM    0(3),X'80'          TEST IF DATA CONVERSION
         JO    MFMT0200            BR IF SO
         SR    15,15               SET REG 15 = 0
         IC    15,0(,3)            LOAD LENGTH OF IN-LINE CHARACTER   ->
                                    STRING
         LA    0,1(,3)             LOAD START OF IN-LINE CHARACTER    ->
                                    STRING
         LR    1,15                COPY LENGTH TO REG 1
         MVCL  14,0                COPY IN-LINE CHARACTER STRING TO   ->
                                    NEW LINE
         LR    3,0                 COPY START OF NEXT FORMAT TO REG 3
         J     MFMT0100            GO CHECK THE NEXT FORMAT
MFMT0200 IC    15,0(,3)            LOAD FORMAT TYPE
         N     15,=A(X'3F')        ISOLATE TYPE
         CHI   15,10               COMPARE WITH MAX
         JH    MFMT7500            BR TO FORMAT ERROR
         SLL   15,2                MULTIPLY TYPE BY 4
         B     *+4(15)             BR TO JUMP TABLE ENTRY
         J     MFMT0400            TYPE 0 - CHARACTER
         J     MFMT0800            TYPE 1 - BINARY TO DECIMAL
         J     MFMT1200            TYPE 2 -BINARY TO HEXADECIMAL DIGITS
         J     MFMT0300            TYPE 3 - SAVE LENGTH FOR TYPES 0 & 2
         J     MFMT1700            TYPE 4 - FORMAT SYSTEM DATE AND TIME
         J     MFMT1900            TYPE 5 - FORMAT DATE AND TIME
         J     MFMT6500            TYPE 6 - INSERT BLANKS
         J     MFMT7300            TYPE 7 - TAB
         J     MFMT6600            TYPE 8 - TRANSLATE DCBRECFM
         J     MFMT6900            TYPE 9 - TRANSLATE DCBDSORG
         J     MFMT0810            TYPE 10 - ALTERNATE TYPE 2
*        J     MFMT7500            TYPE 11 NOT SUPPORTED
*        J     MFMT7500            TYPE 12 NOT SUPPORTED
*        J     MFMT7500            TYPE 13 NOT SUPPORTED
*        J     MFMT7500            TYPE 14 NOT SUPPORTED
*        J     MFMT7500            TYPE 15 NOT SUPPORTED
MFMT0300 LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS
         BRAS  15,MFMT5900         GET THE ADDRESS
         MVC   MFMTWLEN,0(4)       SAVE THE LENGTH
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT0400 LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS
         SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         ICM   5,B'0001',1(3)      LOAD THE INPUT LENGTH
         JNZ   *+L'*+4             BR IF INPUT LENGTH IS DEFINED
         IC    5,MFMTWLEN          LOAD SAVED LENGTH
         IC    6,2(,3)             LOAD THE OUTPUT LENGTH
         BRAS  15,MFMT5900         GET THE ADDRESS
         LTR   15,6                TEST IF OUTPUT LENGTH IS SPECIFIED
         JZ    MFMT0500            BR IF NOT
         LR    0,4                 COPY START OF DATA TO REG 0
         LR    1,5                 COPY INPUT LENGTH TO REG 1
*        ICM   1,B'1000',=C' '     LOAD FILL CHARACTER
         O     1,=AL1(C' ',0,0,0)  ADD FILL CHARACTER
         MVCL  14,0                COPY DATA TO OUTPUT AREA
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT0500 LA    15,0(5,4)           PUT END OF INPUT AREA INTO REG 15
MFMT0600 AHI   15,-1               BACKUP 1 BYTE
         CR    15,4                TEST IF START OF DATA
         JE    MFMT0700            BR IF SO
         CLI   0(15),C' '          TEST IF TRAILING BLANK
         JE    MFMT0600            BR IF SO
MFMT0700 LA    1,1(,15)            SET REG 1 TO END OF INPUT
         SR    1,4                 COMPUTE ACTUAL INPUT LENGTH
         LR    0,4                 COPY START OF INPUT TO REG 0
         LR    15,1                COPY LENGTH TO REG 15
         MVCL  14,0                COPY TEXT TO OUTPUT LINE
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT0800 DC    0H'0'
MFMT0810 MVC   MFMTSAVE,0(3)       SAVE THE ENTRY CODE
         NI    MFMTSAVE,X'3F'      DISCARD THE 2 HIGH ORDER BITS
         LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS
         SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         IC    5,1(,3)             LOAD THE INPUT LENGTH
         IC    6,2(,3)             LOAD THE OUTPUT LENGTH
         BRAS  15,MFMT5900         GET THE ADDRESS
         SLL   5,2                 MULTIPLY LENGTH BY 4
         SR    15,15               SET REG 15 = 0
         EX    0,MFMT6400(5)       LOAD THE BINARY VALUE
         CVD   15,MFMTWWRK         CONVERT MFMT0800 VALUE TO PACKED   ->
                                    DECIMAL
         CLI   MFMTSAVE,1          TEST FORMAT CODE
         JE    MFMT0820            BR IF FORMAT 1
         MVC   MFMTWLNG,MFMT8310   COPY THE ALTERNATE EDIT MASK
         LA    1,MFMTWLNG+L'MFMTWLNG-1  LOAD ADDR OF THE DEFAULT 0
         EDMK  MFMTWLNG,MFMTWWRK   EDIT THE NUMBER
         J     MFMT0830
MFMT0820 MVC   MFMTWEWK,MFMT8300   COPY EDIT MASK TO WORK AREA
         LA    1,MFMTWEWK+L'MFMTWEWK-1
         EDMK  MFMTWEWK,MFMTWWRK   CONVERT PACKED DECIMAL VALUE TO    ->
                                    DECIMAL DIGITS
MFMT0830 LTR   15,15               TEST VALUE
         JNM   MFMT0900            BR IF VALUE IS +
         AHI   1,-1                BACKUP START OF NUMBER BY 1
         MVI   0(1),C'-'           INSERT A MINUS SIGN
MFMT0900 LR    0,1                 COPY START OF VALUE TO REG 0
         LA    1,MFMTWEWK+L'MFMTWEWK  LOAD END OF VALUE
         CLI   MFMTSAVE,1          ALTERNATE FORMAT?
         JE    *+L'*+4             BR IF NOT
         LA    1,MFMTWLNG+L'MFMTWLNG  LOAD ALTERNATE END
         SR    1,0                 COMPUTE LENGTH OF NUMBER
         LTR   6,6                 TEST OUTPUT LENGTH
         JZ    MFMT1100            BR IF 0
         CR    6,1                 COMPARE OUTPUT LENGTH WITH MAX
         JNL   MFMT1000            BR IF NUMBER WILL FIT IN FIELD
         LR    15,6                COPY LENGTH TO REG 15
         L     1,=AL1(C'*',0,0,0)  LOAD FILL CHARACTER
         MVCL  14,0                INSERT *S IN THE OUTPUT FIELD
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT1000 LR    5,14                SAVE ADDRESS OF OUTPUT
         L     7,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER
         LR    15,6                COPY FIELD LENGTH TO REG 15
         MVCL  14,6                CLEAR THE OUTPUT FIELD
         LR    14,5                COPY START OF OUTPUT FIELD TO REG 14
         LR    15,6                COPY OUTPUT FIELD LENGTH TO REG 15
         SR    15,1                COMPUTE NUMBER OF LEADING BLANKS
         AR    14,15               COMPUTE START OF NUMBER IN OUTPUT
MFMT1100 LR    15,1                COPY LENGTH TO REG 15
         MVCL  14,0                COPY CONVERTED VALUE TO OUTPUT
         J     MFMT0100            GO DO THE NEXT FORMAT
* TRANSLATE INPUT BINARY DATA TO HEXADECIMAL DIGITS
* JUST THE INPUT LENGTH IS USED, AN OUTPUT LENGTH IS IGNORED
MFMT1200 LA    1,3(,3)             LOAD ADDRESS OF ADDRESS
         SR    5,5                 SET REG 5 = 0
         ICM   5,B'0001',1(3)      LOAD THE INPUT LENGTH
         JNZ   *+L'*+4             BR IF INPUT LENGTH IS DEFINED
         IC    5,MFMTWLEN          LOAD SAVED INPUT LENGTH
         BRAS  15,MFMT5900         GET THE ADDRESS
MFMT1300 CHI   5,7                 TEST REMINING LENGTH
         JNH   MFMT1400            BR IF 7 OR FEWER BYTES REMAIN
         UNPK  0(15,14),0(8,4)     TRANSLATE 7 BYTES TO HEX DIGITS
         TR    0(14,14),MFMT8200
         AHI   14,14               BUMP THE OUTPUT POINTER
         AHI   4,7                 BUMP THE INPUT POINTER
         AHI   5,-7                REDUCE REMAINING LENGTH BY 7
         J     MFMT1300            GO DO THE NEXT GROUP
MFMT1400 LR    1,5                 COPY REMAINING LENGTH TO REG 1
         SLL   1,5                 GET OUTPUT LENGTH
         OR    1,5                 ADD IN INPUT LENGTH
         EX    1,MFMT1500          TRANSLATE LAST GROUP OF BYTES
         SRL   1,4                  TO HEXADECIMAL DIGITS
         EX    1,MFMT1600
         AR    14,1                UPDATE THE OUTPUT POINTER
         J     MFMT0100            GO CHECK THE NEXT FORMAT
MFMT1500 UNPK  0(*-*,14),0(*-*,4)  ** EXECUTE ONLY **
MFMT1600 TR    0(*-*,14),MFMT8200  ** EXECUTE ONLY **
* FORMAT SYSTEM DATE AND TIME
MFMT1700 CLI   MFMTWFLG,0          TEST IF SYSTEM TIME OBTAINED
         JNE   MFMT1800            BR IF SO
         ST    14,MFMTWDT          SAVE REG 14
         TIME  DEC                 GET THE SYSTEM DATE AND TIME
         L     14,MFMTWDT          RESTORE REG 14
         STM   0,1,MFMTWDT         STORE THE DATE AND TIME
         MVI   MFMTWFLG,255        INDICATE DATE AND TIME IN WORK AREA
MFMT1800 SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         IC    5,1(,3)             LOAD THE DATE CODE
         IC    6,2(,3)             LOAD THE TIME CODE
         LA    3,3(,3)             LOAD ADDRESS OF THE NEXT FORMAT
         LA    4,MFMTWDT           LOAD ADDRESS OF THE DATE AND TIME
         J     MFMT2000            BR TO DATE/TIME COMMON CODE
* FORMAT DATE AND TIME FROM STORAGE REPRESENTING REG 0 AND REG 1
* AFTER EXECUTING A TIME DEC MACRO
MFMT1900 SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         IC    5,1(,3)             LOAD THE DATE CODE
         IC    6,2(,3)             LOAD THE TIME CODE
         LA    1,3(,3)             LOAD THE ADDRESS OF THE ADDRESS
         BRAS  15,MFMT5900         GET THE DATA AREA ADDRESS
MFMT2000 LTR   5,5                 TEST IF DATE WANTED
         JZ    MFMT5010            BR IF NOT
         ICM   9,B'1111',4(4)      LOAD THE DATE
         JNZ   MFMT2010            BR IF DATE IS PRSENT
         SR    1,1                 SET DAY OF MONTH = 0
         SR    8,8                 SET MONTH = 0
         MVC   MFMTWEWK+L'MFMTWEWK-3-4(4),=C'0000' SET YEAR IN MFMTWEWK
         J     MFMT2210            AND CONTINUE
MFMT2010 ZAP   MFMTWWRK,4(4,4)     COPY THE DATE TO THE WORK AREA
         CVB   9,MFMTWWRK          CONVERT THE DATE TO BINARY
         A     9,=F'1900000'       CONVERT THE YEAR FROM CYY TO A     ->
                                    TRUE YEAR
         CVD   9,MFMTWWRK          CONVERT YYYYDDD TO PACKED DECIMAL
         UNPK  MFMTWEWK,MFMTWWRK   CONVERT YYYYDDD TO DECIMAL.  THE   ->
                                    DDD IS NOT USABLE, BUT THE YYYY IS
         SR    8,8                 SET REG 8 = 0
         D     8,=F'1000'          ISOLATE THE YEAR
         LR    1,8                 COPY THE DAY OF YEAR TO REG 1
         SR    8,8                 SET REG 8 = 0
         LR    0,9                 COPY YEAR TO REG 0
         N     0,=A(B'11')         TEST IF YEAR DIVISIBLE BY 4
         JNZ   MFMT2100            BR IF NOT, IT CAN'T BE A LEAP YEAR
         D     8,=F'100'           DIVIDE YEAR BY 100
         LTR   8,8                 TEST REMAINDER
         JNZ   MFMT2200            YEAR IS NOT A CENTURY YEAR, SO IT  ->
                                    MUST BE A LEAP YEAR
         N     9,=A(B'11')         TEST IF YEAR CAN BE DIVIDED BY 400
         JZ    MFMT2200            CENTURY YEAR IS A LEAP YEAR
MFMT2100 CHI   1,31+28             COMPARE DAY OF YEAR WITH FEB 28
         JNH   MFMT2200            BR IF DAY OF YEAR DOES NOT HAVE    ->
                                    TO BE ADJUSTED
         AHI   1,1                 PRETEND DAY OF YEAR IS IN A LEAP   ->
                                    YEAR
MFMT2200 SR    8,8                 SET REG 8 = 0
         IC    8,MFMT8600(1)       LOAD THE MONTH FOR THE DAY OF YEAR
         SLL   8,1                 MULTIPLY MONTH BY 2
         SH    1,MFMT8500(8)       SUBTRACT DAY OF YEAR FOR THE 1ST   ->
                                    DAY OF THE MONTH FROM DAY OF YEAR
         SRL   8,1                 RESET MONTH TO "NORMAL" FORM
* DAY OF MONTH IS IN REG 1, MONTH IS IN REG 8, AND YEAR IN
* CHARACTER FORM IS IN MFMTWEWK
MFMT2210 SLL   5,2                 MULTIPLY DATE CODE BY 4
         B     *(5)                BR
         J     MFMT2300             1 -- FORMAT DATE AS YYYY/MM/DD
         J     MFMT2400             2 -- FORMAT DATE AS YY/MM/DD
         J     MFMT2600             3 -- FORMAT DATE AS MM/DD/YYYY
         J     MFMT2700             4 -- FORMAT DATE AS MM/DD/YY
         J     MFMT2900             5 -- FORMAT DATE AS YYYY MONTH DD
         J     MFMT3000             6 -- FORMAT DATE AS YY MONTH DD
         J     MFMT3200             7 -- FORMAT DATE AS MONTH DD, YYYY
         J     MFMT3300             8 -- FORMAT YEAR AS YYYY
         J     MFMT3400             9 -- FORMAT YEAR AS YY
         J     MFMT3500            10 -- FORMAT MONTH AS MM (NUMERIC)
         J     MFMT3600            11 -- FORMAT MONTH AS MMM
         J     MFMT3700            12 -- FORMAT MONTH AS MONTH
         J     MFMT3710            13 -- FORMAT DAY OF MONTH AS DD
         J     MFMT3720            14 -- FORMAT DAY OF YEAR
         J     MFMT7500            15 -- INVALID
MFMT2300 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2310            BR IF DATE PRESENT
         MVC   0(10,14),=CL10'--'  INDICATE MISSING DATE
         AHI   14,10               BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2310 BRAS  15,MFMT3800         COPY THE 4 DIGIT YEAR
         J     MFMT2500            AND CONTINUE
MFMT2400 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2410            BR IF DATE PRESENT
         MVC   0(8,14),=CL10'--'   INDICATE MISSING DATE
         AHI   14,8                BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2410 BRAS  15,MFMT3900         COPY THE 2 DIGIT YEAR
MFMT2500 BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4300         INSERT MM
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4800         INSERT DD
         J     MFMT5000            TEST IF TIME
MFMT2600 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2610            BR IF DATE PRESENT
         MVC   0(10,4),=CL10'--'   INDICATE MISSING DATE
         AHI   14,10               BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2610 BRAS  15,MFMT4300         INSERT MM
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4800         INSERT DD
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT5000            TEST IF TIME
MFMT2700 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2710            BR IF DATE PRESENT
         MVC   0(8,14),=CL10'--'   INDICATE MISSING DATE
         AHI   14,8                BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2710 BRAS  15,MFMT4300         INSERT MM
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4800         INSERT DD
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT3900         INSERT YY
         J     MFMT5000            TEST IF TIME
MFMT2800 NOPR  0                   ** NOT USED! **
MFMT2900 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2910            BR IF DATE PRESENT
         MVC   0(10,4),=CL10'--'   INDICATE MISSING DATE
         AHI   14,10               BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2910 BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT3100
MFMT3000 BRAS  15,MFMT3900         INSERT YY
MFMT3100 BRAS  15,MFMT4100         INSERT A SPACE
         BRAS  15,MFMT4400         INSERT LONG MONTH
         BRAS  15,MFMT4100         INSERT A SPACE
         BRAS  15,MFMT4800         INSERT DD
         J     MFMT5000            TEST IF TIME
* FORMAT MONTH DD, YYYY
MFMT3200 BRAS  15,MFMT4400         INSERT A LONG MONTH
         BRAS  15,MFMT4100         INSERT A SPACE
         BRAS  15,MFMT4800         INSERT DD
         BRAS  15,MFMT4210         INSERT C', '
         BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT5000            TEST IF TIME
* FORMAT YYYY
MFMT3300 BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT5000            TEST IF TIME
* FORMAT YY
MFMT3400 BRAS  15,MFMT3900         INSERT YY
         J     MFMT5000            TEST IF TIME
* FORMAT MM (NUMERIC MONTH)
MFMT3500 BRAS  15,MFMT4300         INSERT MM
         J     MFMT5000            TEST IF TIME
* FORMAT MMM (ABBREVIATED MONTH)
MFMT3600 BRAS  15,MFMT4700         INSERT MMM
         J     MFMT5000            TEST IF TIME
* INSERT FULL MONTH NAME
MFMT3700 BRAS  15,MFMT4400
         J     MFMT5000            TEST IF TIME
* INSERT DD
MFMT3710 BRAS  15,MFMT4800         INSERT DD
         J     MFMT5000            TEST IF TIME
* INSERT DDD (DAY OF YEAR)
MFMT3720 UNPK  MFMTWWRK,4(4,4)     CONVERT 0CYYDDD TO DECIMAL
         OI    MFMTWWRK+7,X'F0'    MAKE SURE THE LAST BYTE IS A DIGIT
         MVC   0(3,14),MFMTWWRK+5  COPY DDD TO OUTPUT
         AHI   14,3                UPDATE THE OUTPUT POINTER
         J     MFMT5000            TEST IF TIME
* GET THE 4 DIGIT YEAR
MFMT3800 MVC   0(4,14),MFMTWEWK+L'MFMTWEWK-3-4  COPY THE YEAR
         AHI   14,4                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* GET THE 2 DIGIT YEAR
MFMT3900 MVC   0(2,14),MFMTWEWK+L'MFMTWEWK-3-2  COPY THE YEAR
         AHI   14,2                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* INSERT A /
MFMT4000 MVI   0(14),C'/'          INSERT A /
         J     MFMT4200            UPDATE POSITION AND RETURM
* INSERT A SPACE
MFMT4100 MVI   0(14),C' '          INSERT A BLANK
MFMT4200 AHI   14,1                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* INSERT C', '
MFMT4210 MVC   0(2,14),=C', '      COPY C', ' TO OUTPUT
         AHI   14,2                UPDATE OUTPUT POINTER
         BR    15                  AND RETURN
* INSERT 2 DIGIT MONTH
MFMT4300 CVD   8,MFMTWWRK          CONVERT MONTH TO PACKED DECIMAL
         J     MFMT4900            CONTINUE
* INSERT FULL MONTH NAME
MFMT4400 LR    9,8                 COPY REG 8 TO REG 9
         MHI   9,9                 MULTIPLY MONTH BY LENGTH OF A MONTH
         LA    10,MFMT8700+9(9)    LOAD END OF MONTH NAME
         LA    9,MFMT8700(9)       LOAD START OF THE MONTH NAME
MFMT4500 BCTR  10,0                BACKUP 1 BYTE
         CLI   0(10),C' '          TEST FOR TRAILING BLANK
         JE    MFMT4500            BR IF TRAILING BLANK
         SR    10,9                COMPUTE LENGTH TO MOVE
         EX    10,MFMT4600         MOVE MONTH NAME TO OUTPUT LINE
         LA    14,1(10,14)         COMPUTE ADDRESS OF NEXT OUTPUT BYTE
         BR    15                  AND RETURN
MFMT4600 MVC   0(*-*,14),0(9)      ** EXECUTE ONLY **
* INSERT ABBREVIATED MONTH
MFMT4700 LR    9,8                 COPY REG 8 TO REG 9
         MHI   9,9                 MULTIPLY MONTH BY 9
         LA    9,MFMT8700(9)       COMPUTE ADDRESS OF MONTH NAME
         MVC   0(3,14),0(9)        COPY ABBREVIATED MONTH TO OUTPUT
         AHI   14,3                UPDATE OUTPUT POSITION
         BR    15                  AND RETURN
* INSERT DAY OF MONTH
MFMT4800 CVD   1,MFMTWWRK          CONVERT DAY OF MONTH TO PACKED DEC
MFMT4900 OI    MFMTWWRK+7,X'0F'    MAKE SURE THE LAST NIBBLE IS OK
         UNPK  0(2,14),MFMTWWRK    CONVERT VALUE TO DECIMAL
         AHI   14,2                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* TEST IF TIME WANTED
MFMT5000 LTR   6,6                 TEST TIME CODE
         JZ    MFMT0100            BR IF TIME NOT WANTED
         MVI   0(14),C' '          INSERT A BLANK
         AHI   14,1                BUMP THE OUTPUT POSITION
         J     MFMT5020
MFMT5010 LTR   6,6                 TEST TIME CODE
         JZ    MFMT0100            BR IF TIME NOT WANTED
MFMT5020 CHI   6,4                 TEST IF SUPPORTED
         JH    MFMT7500            BR IF NOT SUPPORTED
         SLL   6,2                 MULTIPLY TIME CODE BY 4
         B     *(6)                BR BASED ON TIME CODE
         J     MFMT5100             1 - HH:MM
         J     MFMT5200             2 - HH:MM AM (OR PM)
         J     MFMT5300             3 - HH:MM:SS
         J     MFMT5400             4 - HH:MM:SS AM (OR PM)
MFMT5100 MVC   MFMTWEWK(6),MFMT8400  COPY EDIT MASK TO OUTPUT
         ED    MFMTWEWK(6),0(4)    TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(5,14),MFMTWEWK+1  COPY TRANSLATED TIME TO OUTPUT
         AHI   14,5                BUMP THE OUTPUT POINTER
         J     MFMT0100            AND CONTINUE
MFMT5200 MVC   MFMTWEWK(6),MFMT8400  COPY EDIT MASK TO OUTPUT
         ED    MFMTWEWK(6),0(4)    TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(5,14),MFMTWEWK+1  COPY TRANSLATED TIME TO OUTPUT
         LA    15,5(,14)           SET REG 15
         J     MFMT5600
MFMT5300 MVC   MFMTWEWK,MFMT8400   COPY EDIT MASK TO WORK AREA
         ED    MFMTWEWK,0(4)       TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(L'MFMT8400-1,14),MFMTWEWK+1  COPY TRANSLATED TIME    ->
                                    TO OUTPUT
         AHI   14,L'MFMT8400-1     BUMP THE OUTPUT POINTER
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT5400 MVC   MFMTWEWK,MFMT8400   COPY EDIT MASK TO WORK AREA
         ED    MFMTWEWK,0(4)       TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(L'MFMT8400-1,14),MFMTWEWK+1  COPY TRANSLATED TIME    ->
                                    TO OUTPUT
         LA    15,L'MFMT8400-1(,14)  SET REG 15
MFMT5600 CLI   0(4),X'12'          COMPARE ORIGINAL TIME
         JNL   MFMT5700            BR IF PM
         MVC   0(3,15),=C' AM'     ADD AM TO OUTPUT
         CLI   0(4),X'00'          TEST IF 12 AM
         JNE   MFMT5800            BE IF NOT, WE'RE DONE
         MVC   0(2,14),=C'12'      CHANGE 00 TO 12
         J     MFMT5800            AND CONTINUE
MFMT5700 MVC   0(3,15),=C' PM'     INSERT PM
         CLI   0(4),X'12'          TEST IF NOON TO 12:59
         JE    MFMT5800            BR IF SO, TIME DOES NOT HAVE TO    ->
                                    ADJUSTED
         MVC   MFMTWWRK+4(4),0(4)  COPY ORIGINAL TIME TO WORK AREA
         OI    MFMTWWRK+7,X'0F'    SET A VALID SIGN
         SP    MFMTWWRK+4(4),=P'1200000'  ADJUST THE TIME
         MVC   MFMTWWRK(4),=X'402120'  COPY EDIT MASK
         ED    MFMTWWRK(4),MFMTWWRK+4  CONVERT ADJUSTED TIME TO DECIMAL
         MVC   0(2,14),MFMTWWRK+1  REPLACE HH WITH ADJUSTED HH
MFMT5800 LA    14,3(,15)           UPDATE OUTPUT POINTER
         J     MFMT0100            GO DO THE NEXT FORMAT
         CNOP  0,8
* GET THE ADDRESS.  REG 1 POINTS TO THE ADDRESS CONSTANT, REG 3
* POINTS TO THE FORMAT.  ON RETURN, REG 3 PONTS TO THE NEXT FORMAT,
* AND REG 4 CONTAINS THE OPERAND ADDRESS
MFMT5900 TM    0(3),X'40'          TEST IF S-TYPE ADDRESS
         JZ    MFMT6300            BR IF IN-LINE ADDRESS CONSTANT
MFMT6000 LH    2,0(,1)             LOAD OFFSET FROM THE BASE REGISTER
         N     2,=A(X'FFF')        ISOLATE THE OFFSET
         IC    4,0(,1)             LOAD REGISTER
         N     4,=A(X'F0')         ISOLATE THE REGISTER
         SRL   4,2                 TRANSLATE REGISTER VALUE TO WORD   ->
                                    OFFSET
         L     4,MFMT8100(4)       LOAD THE SAVE AREA OFFSET FOR THE  ->
                                    REGISTER
         CHI   4,99                TEST IF REG 13
         JNE   MFMT6100            BR IF NOT
         LR    4,13                COPY REG 13 TO REG 4
         J     MFMT6200            GO ADD THE OFFSET
MFMT6100 L     4,0(4,13)           LOAD THE BASE REGISTER FROM THE    ->
                                    SAVE AREA
MFMT6200 ALR   4,2                 ADD THE OFFSET TO THE BASE REGISTER
         LA    3,2(,1)             COMPUTE THE ADDRESS                ->
                                    OF THE NEXT FORMAT
         BR    15                  GO TO THE CONVERSION ROUTINE
MFMT6300 ICM   4,B'1111',0(1)      LOAD THE DATA ADDRESS
         LA    3,4(,1)             LOAD ADDRESS OF THE NEXT FORMAT
         BR    15                  GO TO THE CONVERSION ROUTINE
MFMT6400 J     MFMT7500            LENGTH 0, FORMAT ERROR
         IC    15,0(,4)            LENGTH 1, LOAD 1 BYTE
         ICM   15,B'0011',0(4)     LENGTH 2, LOAD 2 BYTES
         ICM   15,B'0111',0(4)     LENGTH 3, LOAD 3 BYTES
         ICM   15,B'1111',0(4)     LENGTH 4, LOAD 4 BYTES
MFMT6500 SR    15,15               SET REG 15 = 0
         L     1,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER
         IC    15,1(,3)            LOAD NUMBER OF BLANKS TO INSERT
         AHI   3,2                 COMPUTE ADDRESS OF THE NEXT FORMAT
         MVCL  14,0                INSERT THE BLANKS
         J     MFMT0100            GO PROCESS THE NEXT FORMAT
* TRANSLATE DCBRECFM TO A CHARACTER STRING
MFMT6600 SR    6,6                 SET REG 6 = 0
         IC    6,2(,3)             LOAD THE OUTPUT LENGTH
         LA    1,3(,3)             LOAD ADDRESS OF THE ADDRESS
         BRAS  15,MFMT5900         GET THE ADDRESS
         MVC   MFMTWEWK(5),=CL8' ' CLEAR THE TEMPORARY OUTPUT
         TM    0(4),DCBRECL        TEST IF RECFM IS VALID
         JNZ   MFMT6610            BR IF A RECORD TYPE IS DEFINED
         MVI   MFMTWEWK,C'?'       INDICATE RECFM IS INVALID
         LA    15,MFMTWEWK+1       SET REG 15 = END OF DATA
         J     MFMT7200            AND EXIT
MFMT6610 LA    15,MFMTWEWK         LOAD ADDRESS OF THE TEMPORARY OUTPUT
         LA    0,MFMT7800          LOAD ENTRIES IN THE CONVERSION TABLE
         LA    1,MFMT7700          LOAD ADDR OF THE CONVERSION TABLE
MFMT6700 MVC   MFMTWEWK+5(1),0(4)  SAVE A COPY OF THE RECFM
         NC    MFMTWEWK+5(1),0(1)  ISOLATE TEST BITS
         CLC   MFMTWEWK+5(1),1(1)  TEST RECFM
         JNE   MFMT6800            BR OPTION NOT PRESENT
         MVC   0(1,15),2(1)        COPY THE OPTION CHARACTER
         AHI   15,1                UPDATE THE OUTPUT ADDR
MFMT6800 AHI   1,3                 COMPUTE ADDR OF NEXT RECFM         ->
                                    CONVERSION TABLE ENTRY
         BRCT  0,MFMT6700          GO DO IT
         J     MFMT7200
* TRANSLATE DCBDSORG TO A CHARACTER STRING
MFMT6900 SR    6,6                 SET OUTPUT LENGTH = 0
         IC    6,2(,3)             LOAD OUTPUT LENGTH
         LA    1,3(,3)             LOAD ADDRESS OF THE ADDRESS
         BRAS  15,MFMT5900         GET THE ACTUAL ADDRESS
         LA    0,MFMT8000          LOAD ENTRIES IN DSORG TABLE
         LA    1,MFMT7900          LOAD ADDR OF START OF THE DSORG TAB
MFMT7000 CLC   0(2,4),0(1)         TEST IF MATCH
         JE    MFMT7100            BE IF SO
         AHI   1,5                 COMPUTE ADDR OF NEXT DSORG ENTRY
         BRCT  0,MFMT7000          GO CHECK IT
MFMT7100 MVC   MFMTWEWK(3),2(1)    COPY DSORG TEXT
         LA    15,MFMTWEWK+3       LOAD END OF DSORG
         CLI   MFMTWEWK+2,C' '     TEST IF 3 BYTE DSORG
         BNE   MFMT7200            BR IF SO
         BCTR  15,0                RESET END OF DSORG
MFMT7200 LR    5,15                COPY END OF TEXT TO REG 5
         LA    4,MFMTWEWK          LOAD ADDRESS OF CONVERTED TEXT
         SR    5,4                 COMPUTE LENGTH OF CONVERTED TEXT
         LTR   6,6                 TEST OUTPUT LENGTH
         JNZ   *+L'*+2             BR IF OUTPUT LENGTH DEFINED
         LR    6,5                 COPY INPUT LENGTH TO OUTPUT LENGTH
         O     5,=AL1(C' ',0,0,0)  ADD FILL CHARACTER TO INPUT LENGTH
         LR    15,6                COPY OUTPUT LENGTH TO REG 15
         MVCL  14,4                COPY RECFM TEXT TO OUTPUT
         J     MFMT0100            GO DO THE NEXT FORMAT
* TAB -- REPOSITION OUTPUT POINTER, INSERT BLANKS IF TAB > CURRENT
*        LINE POSITION
MFMT7300 SR    15,15               SET REG 15 = 0
         IC    15,1(,3)            LOAD TAB POSITION
         AHI   3,2                 UPDATE FORMAT POSITION
         LA    15,MFMTWLNE+4(15)   COMPUTE TAB POSITION IN OUTPUT     ->
                                    BUFFER
         CR    15,14               COMPARE TAB POSITION W/ CURRENT    ->
                                    LINE POSITION
         JH    MFMT7400            BR IF FORWARD TAB
         JE    MFMT0100            NO MOVEMENT, IGNORE
         LR    14,15               BACKWARDS, SET NEW OUTPUT POSITION
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT7400 SR    15,14               COMPUTE NUMBER OF BLANKS TO INSERT
         L     1,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER INTO REG 1
         MVCL  14,0                INSERT BLANKS TO NEW TAB
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT7500 MVC   0(5,14),=C'*FMT*'   INDICATE A FORMAT PROBLEM
         AHI   14,5                UPDATE THE OUTPUT POINTER
MFMT7600 LA    1,MFMTWLNE          LOAD ADDR OF GENERATED LINE
         SR    14,1                COMPUTE LENGTH OF GENERATED LINE
         STH   14,0(,1)            STORE LENGTH IN THE RDW
         XC    2(2,1),2(1)         CLEAR THE REMAINDER OF THE RDW
         ST    1,24(,13)           REPLACE CALLER'S REG 1 WITH        ->
                                    ADDRESS OF GENERATED OUTPUT LINE
         RETURN (14,12),T          RESTORE REGS & RETURN TO CALLER
MFMT7700 DC    AL1(DCBRECL,DCBRECF,C'F') TABLE TO
         DC    AL1(DCBRECL,DCBRECV,C'V')  TRANSLATE
         DC    AL1(DCBRECL,DCBRECU,C'U')   DCBRECFM
*        DC    AL1(DCBRECL,0,C'?')          TO A
         DC    AL1(DCBRECBR,DCBRECBR,C'B')   CHARACTER
         DC    AL1(DCBRECSB,DCBRECSB,C'S')    STRING
         DC    AL1(DCBRECTO,DCBRECTO,C'T')
         DC    AL1(DCBRECCC,DCBRECCA,C'A')
         DC    AL1(DCBRECCC,DCBRECCM,C'M')
MFMT7800 EQU   (*-MFMT7700)/3      NUMBER OF ENTRIES IN MFMT7700 TABLE
MFMT7900 DC    AL1(DCBDSGPS,0),CL3'PS'         TABLE TO
         DC    AL1(DCBDSGPO,0),CL3'PO'          TRANSLATE
         DC    AL1(DCBDSGIS,0),CL3'IS'           DCBDSORG
         DC    AL1(DCBDSGDA,0),CL3'DA'            TO A
         DC    AL1(0,DCBACBM),CL3'VS'              CHARACTER STRING
         DC    AL1(DCBDSGPS+DCBDSGU,0),CL3'PSU'
         DC    AL1(DCBDSGPO+DCBDSGU,0),CL3'POU'
         DC    AL1(DCBDSGIS+DCBDSGU,0),CL3'ISU'
         DC    AL1(DCBDSGDA+DCBDSGU,0),CL3'DAU'
MFMT8000 EQU   (*-MFMT7900)/5      NUMBER OF ENTRIES IN MFMT7900 TABLE
         DC    2AL1(0),CL3'??'
* THE MFMT8100 TABLE TRANSLATES A REGISTER NUMBER TO THE OFFSET
* OF THE REGISTER LOCATION IN THE SAVE AREA USED WHEN MINIFMT IS
* CALLED.  SINCE REGISTERS 14, 15, 0 AND 1 ARE LINK REGISTERS WHEN
* MICROFMT IS CALLED THEY ARE NOT VERY USEFUL FOR THE PURPOSE, BUT
* REGISTERS 2 THROUGH 13 ARE USEFUL.
*             REG 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
MFMT8100 DC    A(20,24,28,32,36,40,44,48,52,56,60,64,68,99,12,16)
MFMT8200 EQU   *-C'0'
         DC    C'0123456789ABCDEF'
*                  ----+----1----+
MFMT8300 DC    0C' 999999999999999',C' ',13X'20',X'2120'
MFMT8310 DC    0C' 999,999,999,999,999'
         DC    C' ',3X'20',C',',3X'20',C',',3X'20',C',',3X'20',C',',X'2>
               02120'
*                 0----+---
MFMT8400 DC    0C'0HH:MM:SS',C'0',X'2120',C':',X'2020',C':',X'2020'
* DAY OF YEAR FOR 1ST DAY OF MONTH
         DC    0H'0'
MFMT8500 EQU   *-2
         DC    AL2(0)                                JANUARY
         DC    AL2(31)                               FEBRUARY
         DC    AL2(31+29)                            MARCH
         DC    AL2(31+29+31)                         APRIL
         DC    AL2(31+29+31+30)                      MAY
         DC    AL2(31+29+31+30+31)                   JUNE
         DC    AL2(31+29+31+30+31+30)                JULY
         DC    AL2(31+29+31+30+31+30+31)             AUGUST
*                                                    ----+----
         DC    AL2(31+29+31+30+31+30+31+31)          SEPTEMBER
         DC    AL2(31+29+31+30+31+30+31+31+30)       OCTOBER
         DC    AL2(31+29+31+30+31+30+31+31+30+31)    NOVEMBER
         DC    AL2(31+29+31+30+31+30+31+31+30+31+30) DECEMBER
* TRANSLATE DAY OF YEAR TO MONTH
* JANUARY TO JUNE
MFMT8600 DC    32AL1(1),29AL1(2),31AL1(3),30AL1(4),31AL1(5),30AL1(6)
* JULY TO DECEMBER
         DC    31AL1(7),31AL1(8),30AL1(9),31AL1(10),30AL1(11),31AL1(12)
* MONTH NUMBER TO MONTH NAME, ABBREVIATED MONTH NAME IS THE FIRST 3
* CHARACTERS OF THE FULL MONTH NAME
MFMT8700 DC    CL9'--'
         DC    CL9'JANUARY',CL9'FEBRUARY',CL9'MARCH'
         DC    CL9'APRIL',CL9'MAY',CL9'JUNE'
         DC    CL9'JULY',CL9'AUGUST',CL9'SEPTEMBER'
         DC    CL9'OCTOBER',CL9'NOVEMBER',CL9'DECEMBER'
         DC    0D'0'
         LTORG ,
         DC    0D'0'
         DROP  ,
         TITLE 'CNVTBIN -- Translate Time of Day As Returned by TIME BI>
               N to Time of Day As Returned by TIME DEC'
***********************************************************************
*                                                                     *
* Title -- CNVTBIN                                                    *
*                                                                     *
* Function / Operation -- CNVTBIN converts the time of day as         *
*   returned by the TIME BIN macro to the time of day as returned     *
*   by the TIME DEC macro.                                            *
*                                                                     *
* Calling Sequence --                                                 *
*   ----+----1----+----2----+----3----+----4----+----5----+----6----+ *
*            TIME  BIN                 (or equivalent)                *
*            L     15,=V(CNVTBIN)      Load address of CNVTBIN        *
*            BASR  14,15               Convert binary time of day     *
*   *                                   to 8 packed decimal digits    *
*   * Time of day is in reg 0                                         *
*   * CNVTBIN can also be called using the BRAS or BRASL instructions *
*                                                                     *
* Status / Change Level --                                            *
*   V2L0 -- May 2010                                                  *
*    - Replace lost source                                            *
*                                                                     *
* Method of Operation -- Prepare a binary number that is the analog   *
*   of the number returned by TIME DEC, convert the number to the     *
*   5 byte equivalent of the packed decimal equivalent of the value   *
*   returned by TIME DEC, store the decimal digits in reg 0 and       *
*   return.                                                           *
*                                                                     *
***********************************************************************
         SPACE 5
         ENTRY CNVTBIN
         AGO   .NEWBIN
CNVTBIN  BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,15                ESTABLISH ADDRESSABILITY
         SAVE  (14,3),,CNVTBIN     SAVE REGISTERS 14 THROUGH 3        ->
                                    (THE SAVE AREA POSITIONS FOR      ->
                                     REGISTERS 11 AND 12 WILL BE USED ->
                                      AS A WORK AREA)
         LR    3,0                 COPY THE TIME BIN VALUE TO REG 3
         SR    2,2                 SET REG 2 = 0
         D     2,=F'100'           DIVIDE BY NUMBER OF 1/100TH OF A   ->
                                    SECONDS IN A SECOND
         LR    0,2                 COPY 1/100THS OF A SECOND TO REG 0
         SR    2,2                 SET REG 2 = 0
         D     2,=F'60'            DIVIDE SECONDS BY SECONDS IN 1     ->
                                    MINUTE
         MHI   2,100               MULTIPLY SECONDS BY 100
         AR    0,2                 ADD TO TOTAL
         SR    2,2                 SET REG 2 = 0
         D     2,=F'60'            DIVIDE MINUTES BY 60
* WE HAVE MINUTES IN AN HOUR IN REG 2, AND THE HOUR OF THE DAY IN REG 3
         MHI   2,10000             MULTIPLY MINUTES BY 10000
         AR    0,2                 ADD TO TOTAL
         SR    2,2                 SET REG 2 = 0
         M     2,=F'1000000'       MULTIPLY HOUR OF THE DAY BY 1000000
         AR    0,3                 ADD TO TOTAL
         CVD   0,64(,13)           CONVERT TIME TO PACKED DECIMAL
         LM    0,1,64(13)          LOAD TIME
         SRDL  0,4                 REMOVE THE PACKED DECIMAL SIGN
         ST    1,20(,13)           REPLACE CALLER'S REG 0 WITH RESULT
         RETURN (14,3),T           RESTORE CALLER'S REGISTERS & RETURN
         DC    0D'0'               FORCE DOUBLE WORD ALIGNMENT
         LTORG ,                   DEFINE THE LITERAL POOL
         DC    0D'0'               FORCE DOUBLE WORD ALIGNMENT
         SPACE 1
         DROP  ,                   KILL ADDRESSABILITY
.NEWBIN  ANOP
CNVTBIN  BASR  15,0                Store current address in reg 15
         USING *,15                Establish addressability
         SAVE  (14,1),,CNVTBIN     Save registers
         LR    1,0                 Copy reg 0 to reg 1
         SR    0,0                 Compute minutes (in reg 1)
         D     0,=F'6000'           and seconds (in reg 0)
         LR    14,0                Copy seconds to reg 14
         SR    0,0                 Compute hours (in reg 1)
         D     0,=F'60'             and minutes (in reg 0)
         MHI   0,10000             Multiply minutes by 10000
         AR    14,0                Combine minutes and seconds
         MHI   1,1000              Multiply hours by 1000000
         MHI   1,1000
         AR    14,1                Combine hours with minutes & seconds
         MHI   14,10               Multiply F'hhmmssss' by 10
         CVD   14,64(,13)          Convert F'hhmmssss0' to decimal
         MVC   20(4,13),67(13)     Replace caller's reg 0 with hhmmssss
         RETURN (14,1)             Restore registers & return
         DC    0D'0'
         LTORG ,
         DC    0D'0'
         DROP   ,                  Kill addressability
         TITLE 'LJUST            L E F T   J U S T I F Y   R I G H T   >
               J U S T I F I E D   D A T A'
* Left justify right justified justifed data
*          LA    0,L'DATA
*          LA    1,DATA
*          L     15,=V(LJUST)
*          CALL  (15)
*          ...
* DATA     DC    C'  DATA'
*
* Output is C'DATA  '
*
* An alternative, slightly faster though more expensive in storage,
* inplementation is expressed in comments.
         SPACE 1
         ENTRY LJUST               Define external entry point
LJUST    BASR  15,0                Store current address in reg 15
         USING *,4                 Establish program addressability
         SAVE  (14,4),,LJUST       Save registers
         LR    4,15                Prepare base register
         LR    14,1                Copy start of data to reg 14 and
         LR    2,1                  reg 2
         LTR   3,0                 Copy length to reg 3
         JNP   LJ0300              Br if length is bad
**       LA    1,0(3,2)            Compute address of end of data
*        LR    15,0                Copy length to reg 15
*        BCTR  15,0                Compute length to test
*        EX    15,LJ0500           Find first non-blank
*        JZ    LJ0300              All blanka, exit
LJ0100   TM    0(1),255-C' '       Find first non-blank
         JNZ   LJ0200              Br if found
         AHI   1,1                 Update reg 1
         BRCT  0,LJ0100            Keep on looking
         J     LJ0300              All blanks, exit
LJ0200   CR    14,1                Test if already left justified
         JE    LJ0300              Br if so
         LA    15,0(3,2)           Compute addr of end of data
         SR    15,1                Compute length to copy
         JNP   LJ0300              Oops
         BCTR  15,0                Reduce length by 1 for hardware
         EX    15,LJ0400           Left justify the data
         LA    14,1(15,14)         Compute end of string we just copied
         LA    15,0(3,2)           Compute end of data
         SR    15,14               Compute bytes to blank
         JNP   LJ0300              Br if none
         L     1,LJ0600            Load the fill character
         MVCL  14,0                Fill the vacated data with blanks
LJ0300   RETURN (14,4)             Restore registers & return
LJ0400   MVC   0(*-*,14),0(1)    **EX only **
*LJ0500  TRT   0(*-*,14),LJ0700  **EX only **
LJ0600   DC    0A(0),C' ',3AL1(0)
         DC    0D'0'
*LJ0700  DC    X'00',(C' '-(*-LJ0700))X'04',X'00',(256-(*-LJ0700))X'04'
         END   ,
